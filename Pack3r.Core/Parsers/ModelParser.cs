using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using Pack3r.Extensions;
using Pack3r.IO;
using Pack3r.Logging;
using Pack3r.Models;

namespace Pack3r.Parsers;

// TODO: support for remapped surfaces

public interface IModelParser
{
    IAsyncEnumerable<ReadOnlyMemory<char>> ParseModelShaders(Map map, CancellationToken cancellationToken);
}

public partial class ModelParser(
    ILogger<ModelParser> logger,
    ILineReader reader/*,
    IProgressManager progressManager*/) : IModelParser
{
    public async IAsyncEnumerable<ReadOnlyMemory<char>> ParseModelShaders(
        Map map,
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        //using var progress = progressManager.Create("Parsing .ase models for shaders", null);
        //int counter = 0;

        foreach (var resource in map.Resources)
        {
            if (resource.Span.EndsWith(".ase", StringComparison.OrdinalIgnoreCase))
            {
                //progress.Report(++counter);

                foreach (var source in map.AssetSources)
                {
                    if (source.TryRead(resource, reader, new LineOptions(), cancellationToken, out var lines))
                    {
                        await foreach (var res in ParseAse(source, resource, lines))
                        {
                            yield return res;
                        }

                        break;
                    }
                }
            }
        }
    }

    public async IAsyncEnumerable<ReadOnlyMemory<char>> ParseAse(AssetSource source, ReadOnlyMemory<char> modelPath, IAsyncEnumerable<Line> lines)
    {
        await foreach (var line in lines)
        {
            if (Matcher.Comment().IsMatch(line.Value.Span))
            {
                if (!line.Value.Span.Contains("Generated by Q3Map2", StringComparison.Ordinal))
                {
                    logger.Warn($"Unsupported .ASE model (not generated by Q3Map2): '{Path.Combine(source.RootPath, modelPath.ToString())}'");
                    yield break;
                }
            }
            else if (line.Value.Span.StartsWithF("*MAP_NAME"))
            {
                if (line.Value.TryReadPastWhitespace(out var token))
                {
                    yield return token.Trim('"');
                }
            }
            else if (line.Value.Span.StartsWithF("*GEOMOBJECT"))
            {
                yield break;
            }
        }
    }

    private static partial class Matcher
    {
        [GeneratedRegex("""\*COMMENT\s""", RegexOptions.Singleline, 1000)]
        public static partial Regex Comment();
    }
}
